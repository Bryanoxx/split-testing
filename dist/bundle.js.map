{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/utils.ts", "../src/utils/weight.ts", "../src/experiment.ts"],
  "sourcesContent": ["export * from './experiment'\r\nexport type { Variant, ExperimentOptions, Storage } from './types'\r\n", "/**\r\n * Logs a message to the console if debug is enabled.\r\n *\r\n * @export\r\n * @param {*} data\r\n * @param {boolean} isDebugging\r\n */\r\nexport function logger (data: any, isDebugging: boolean): void {\r\n  if (isDebugging) {\r\n    console.log('SplitTesting.js -', data)\r\n  }\r\n}\r\n\r\n/**\r\n * Return the log function with a defined debugging state\r\n *\r\n * @export\r\n * @param {boolean} isDebugging\r\n * @return {*}  {(data: any) => void}\r\n */\r\nexport function makeLogger (isDebugging: boolean): (data: any) => void {\r\n  return (data: any) => {\r\n    logger(data, isDebugging)\r\n  }\r\n}\r\n\r\n/**\r\n * Logs a warning message to the console\r\n *\r\n * @export\r\n * @param {*} data\r\n */\r\nexport function warningLogger (data: any): void {\r\n  console.warn('SplitTesting.js -', data)\r\n}\r\n\r\n/**\r\n * Create the error object of the library\r\n *\r\n * @export\r\n * @param {string} message\r\n * @return {*}  {Error}\r\n */\r\nexport function createError (message: string): Error {\r\n  return new Error(`SplitTesting.js - ${message}`)\r\n}\r\n\r\n/**\r\n * Deep clones all properties except Function and RegExp\r\n * Extracted and edited from https://www.npmjs.com/package/just-clone\r\n *\r\n * @export\r\n * @param {*} obj\r\n * @return {*}  {*}\r\n */\r\nexport function deepClone (obj: any): any {\r\n  if (typeof obj === 'function') {\r\n    return obj\r\n  }\r\n  const result: any = Array.isArray(obj) ? [] : {}\r\n  for (var key in obj) {\r\n    const value = obj[key]\r\n    const type = {}.toString.call(value).slice(8, -1)\r\n    if (type === 'Array' || type === 'Object') {\r\n      result[key] = deepClone(value)\r\n    } else if (type === 'Date') {\r\n      result[key] = new Date(value.getTime())\r\n    } else {\r\n      result[key] = value\r\n    }\r\n  }\r\n  return result\r\n}\r\n", "import type { WeightedItem } from '../types'\r\nimport { warningLogger } from './utils'\r\n\r\n/**\r\n * Validate the `weight` property of every item in an array by checking if the total of all weight is equal to 1\r\n *\r\n * @export\r\n * @param {Array<Partial<WeightedItem>>} items\r\n * @return {*}  {boolean}\r\n */\r\nexport function validateWeightProperties (items: Array<Partial<WeightedItem>>): boolean {\r\n  // Extracting weight-related variables\r\n  const hasWeight = items.some(item => item.weight !== undefined)\r\n  const everyHasWeight = items.every(item => item.weight !== undefined)\r\n  const totalWeight = items.reduce((acc, item) => acc + (item.weight ?? 0), 0)\r\n\r\n  // Validating the weigh of the variants\r\n  if (hasWeight && !everyHasWeight) {\r\n    warningLogger('Some items have a weight but not all of them, reset of all weight')\r\n    return false\r\n  } else if (everyHasWeight && totalWeight !== 1) {\r\n    warningLogger('The total of all weight is not equal to 1, reset of all weight')\r\n    return false\r\n  } else if (!hasWeight) {\r\n    // No weight properties at all\r\n    return false\r\n  }\r\n\r\n  // All the variant have a weight property that are coherent\r\n  return true\r\n}\r\n\r\n/**\r\n * Send a new array with each item in equal probability of being picked\r\n *\r\n * @export\r\n * @template T\r\n * @param {T[]} items\r\n * @return {*}  {(Array<T & WeightedItem>)}\r\n */\r\nexport function makeWeightPropertiesEqual<T extends Partial<WeightedItem>> (items: T[]): Array<T & WeightedItem> {\r\n  const weightValue = 1 / items.length\r\n  const newItems = items.map(item => {\r\n    item.weight = weightValue\r\n    return item as T & WeightedItem\r\n  })\r\n  return newItems\r\n}\r\n\r\n/**\r\n * Return a random item from an array (with weighted probability)\r\n * A seed is possible in the goal of always returning the same item\r\n *\r\n * @export\r\n * @template T\r\n * @param {T[]} items\r\n * @param {string} [seed]\r\n * @return {*}  {T}\r\n */\r\nexport function getWeightedRandomElement <T extends Required<WeightedItem>> (items: T[], seed?: string): T {\r\n  let random: number = (seed !== undefined) ? getSeededRandom(seed) : Math.random()\r\n  const weightedRandomItem = items.find(item => {\r\n    if (random < item.weight) {\r\n      return item\r\n    } else {\r\n      random -= item.weight\r\n    }\r\n  })\r\n  return (weightedRandomItem as T)\r\n}\r\n\r\n/**\r\n * Return always the same number between 0 and 1 from the same string\r\n * Here's how : http://indiegamr.com/generate-repeatable-random-numbers-in-js/\r\n *\r\n * @param {string} seed\r\n * @return {*}  {number}\r\n */\r\nfunction getSeededRandom (seed: string): number {\r\n  const seedInNumber = seed.split('').map(char => char.charCodeAt(0)).reduce((acc: number, char: number) => acc + char, 0)\r\n  const calcSeed = (seedInNumber * 9301 + 49297) % 233280\r\n  const random = calcSeed / 233280\r\n  return random\r\n}\r\n", "import type { Variant, WeightedVariant, ExperimentOptions, SafeExperimentOptions } from './types'\r\nimport { validateWeightProperties, makeWeightPropertiesEqual, getWeightedRandomElement } from './utils/weight'\r\nimport { makeLogger, warningLogger, createError, deepClone } from './utils/utils'\r\n\r\n/**\r\n * Configure a split testing experiment with the given options.\r\n *\r\n * @export\r\n * @param {ExperimentOptions} options\r\n * @return {*}  {boolean}\r\n */\r\nexport function setExperiment (options: ExperimentOptions): Variant {\r\n  // Validation of the options\r\n  if (typeof options.name !== 'string' || options.name.length === 0) {\r\n    throw createError('The experiment name must be a non-empty string')\r\n  }\r\n  if (!Array.isArray(options.variants) || options.variants.length === 0) {\r\n    throw createError('The variants must be an array of at least one element')\r\n  }\r\n  const variantsHaveNames = options.variants.every(variant => variant.name !== undefined && variant.name.length > 0)\r\n  if (!variantsHaveNames) {\r\n    throw createError('The variants must have a name')\r\n  }\r\n  options.storage = options.storage ?? (globalThis.window !== undefined ? globalThis.window.localStorage : undefined)\r\n  if (options.storage === undefined) {\r\n    throw createError('No storage available, please define a custom storage property')\r\n  }\r\n\r\n  // Extraction of the options\r\n  const experiment: SafeExperimentOptions = {\r\n    name: options.name,\r\n    variants: deepClone(options.variants),\r\n    seed: options.seed,\r\n    isDebugMode: options.isDebugMode ?? false,\r\n    isResolvingSeedConflictAllowed: options.isResolvingSeedConflictAllowed ?? true,\r\n    storage: options.storage\r\n  }\r\n\r\n  // Configuration of the logget depending on the debug mode\r\n  const logger = makeLogger(experiment.isDebugMode)\r\n  logger('Running split testing with these options :')\r\n  logger(experiment)\r\n\r\n  // Picking the variant or verifying it if it exists\r\n  const pickedVariant = getPickedVariant(experiment)\r\n  if (pickedVariant === null) {\r\n    // Picking the variant for the first time\r\n    logger('No variant picked in storage, picking it now')\r\n    const newlyPickedVariant = pickAndSetVariant(experiment, logger)\r\n    if (experiment.onFirstPicking !== undefined) {\r\n      experiment.onFirstPicking(newlyPickedVariant)\r\n    }\r\n\r\n    return newlyPickedVariant\r\n  } else {\r\n    // Verifying the variant coherencde if it already exists\r\n    logger(`Variant already picked, named ${pickedVariant.name}`)\r\n\r\n    // Checking if the variant name is valid\r\n    if (getPickedVariant(experiment) === undefined) {\r\n      throw createError(`The variant named ${pickedVariant.name} is not valid (not found in the variants)`)\r\n    }\r\n\r\n    // Checking the seed for having a consistent variant\r\n    if (experiment.isResolvingSeedConflictAllowed && experiment.seed !== undefined && !sameLocalAndGivenSeed(experiment)) {\r\n      warningLogger('Conflict between the old seed and the current seed, updating the variant for the current seed')\r\n      const newlyPickedVariant = pickAndSetVariant(experiment, logger)\r\n      return newlyPickedVariant\r\n    }\r\n\r\n    return pickedVariant\r\n  }\r\n}\r\n\r\n/**\r\n * Get all the details of the picked variant from storage\r\n *\r\n * @param {SafeExperimentOptions} experiment\r\n * @return {*}  {(Variant | undefined)}\r\n */\r\nfunction getPickedVariant (experiment: SafeExperimentOptions): Variant | null {\r\n  // Name of the picked variant\r\n  const pickedVariantName = experiment.storage.getItem(`ST-${experiment.name}-variant-name`)\r\n  if (pickedVariantName === null) {\r\n    return null\r\n  }\r\n\r\n  // Finding details of the picked variant\r\n  const pickedVariant = experiment.variants.find(variant => variant.name === pickedVariantName)\r\n  return pickedVariant ?? null\r\n}\r\n\r\n/**\r\n * Set the name and seed of the picked variant in storage\r\n *\r\n * @param {SafeExperimentOptions} { name: experimentName, storage, seed }\r\n * @param {Variant} pickedVariant\r\n * @param {ReturnType<typeof makeLogger>} log\r\n */\r\nfunction setPickedVariant ({ name: experimentName, storage, seed }: SafeExperimentOptions, pickedVariant: Variant, log: ReturnType<typeof makeLogger>): void {\r\n  storage.setItem(`ST-${experimentName}-variant-name`, pickedVariant.name)\r\n  log(`New picked variant: ${pickedVariant.name} ${seed !== undefined ? '(with seed)' : ''}`)\r\n\r\n  // Saving the seed if provided, for further verifications next time the user come\r\n  if (seed !== undefined) {\r\n    storage.setItem(`ST-${experimentName}-seed`, seed)\r\n  } else {\r\n    storage.removeItem(`ST-${experimentName}-seed`)\r\n  }\r\n}\r\n\r\n/**\r\n * Pick and save the variant of the experiment in storage\r\n *\r\n * @param {SafeExperimentOptions} { name: experimentName, variants, storage, seed, onFirstPicking }\r\n * @param {ReturnType<typeof makeLogger>} log\r\n */\r\nfunction pickAndSetVariant (\r\n  experiment: SafeExperimentOptions,\r\n  log: ReturnType<typeof makeLogger>\r\n): Variant {\r\n  // Extracting some properties\r\n  const variants = experiment.variants\r\n  const seed = experiment.seed\r\n\r\n  // Validating the weight of the variants\r\n  const areVariantsWellWeighted = validateWeightProperties(variants)\r\n  const weightedVariants: WeightedVariant[] = areVariantsWellWeighted ? (variants as WeightedVariant[]) : makeWeightPropertiesEqual(variants)\r\n  if (!areVariantsWellWeighted) {\r\n    log('Making all weight equal so the variants have the same probability of being picked')\r\n  }\r\n\r\n  // Random picking of the variant (or constant if seed provided) and saving it in storage\r\n  const pickedVariant = getWeightedRandomElement(weightedVariants, seed)\r\n  setPickedVariant(experiment, pickedVariant, log)\r\n\r\n  return pickedVariant\r\n}\r\n\r\n/**\r\n * Check if the local seed and the given seed are consistent.\r\n *\r\n * @param {SafeExperimentOptions} { name: experimentName, seed, storage }\r\n * @return {*}  {boolean}\r\n */\r\nfunction sameLocalAndGivenSeed ({ name: experimentName, seed, storage }: SafeExperimentOptions): boolean {\r\n  const localSeed = storage.getItem(`ST-${experimentName}-seed`)\r\n  return localSeed === seed\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
